# Thinking in Compose

https://developer.android.com/jetpack/compose/mental-model

Jetpack Composeは宣言的なUIツールキット

## The declarative programming paradigm

AndroidのView階層はUIウィジェットのツリーとして表現されてきた。
ユーザ操作などによってアプリの状態は変更されるので、UI階層は現在のデータで画面を更新する必要がある。
UIを更新する主な方法は、`findViewById()`で取得したViewに対して、`setText`, `addChild`, `setImageBitmap`などを呼び出すこと。
これらのメソッドはウィジェットの内部状態を変更する。

手動でのView操作はエラーが発生しやすくなる。
複数箇所でレンダリングしている場合、1つのViewの更新を忘れがちになる。
また、2つの更新が予期せぬコンフリクトが起きた場合に不正な状態が発生しやすい。
例えば、すでに削除済みのノードの値を更新が行われるなど。
一般的に、ソフトウェアのメンテナンスの複雑度は更新が必要なViewの数が多いほど大きくなる。

ここ数年、業界全体が宣言的UIモデルへの意向を始めていて、UIの構築と更新に関連する実装を簡素化している。
この技術は画面をゼロから再生成し、必要な変更のみを適用することで動作する。
この手法はステートフルなView階層を手動で更新する複雑さを回避する。
Composeは宣言的UIフレームワーク

画面全体を再生成する場合の課題として、時間、計算能力バッテリー使用量などでコストがかかる可能性がある。
このコストを軽減するために、Composeはどの部分が再描画の必要があるのかをかしこく選択する。
[Recomposition](https://developer.android.com/jetpack/compose/mental-model#recomposition)で説明されているようにUIコンポーネントの設計方法にいくつかの意味を持つ。

## A simple composable function

Composeの利用ではUIの構築にComposable関数を定義する。

この点について注目するべきは

* `@Composable`を定義する必要がある
* Composable関数は引数を受け付けUIの記述にロジックを書くことができる
* Composable関数内で`Text()`などの別のComposable関数を呼び出すことができる
* Composable関数の戻り値はない
* Composable関数は高速で、副作用がない
  * [疑問点] idempotent？

一般的に、Composable関数は[Recomposition](https://developer.android.com/jetpack/compose/mental-model#recomposition)で説明されている理由からこれらの特性に従って記述する必要がある

## The declarative paradigm shift

多くのオブジェクト指向のUIツールキットではウィジェットのツリーをインスタンス化することで初期化する。
これはxmlファイルをインフレートで行うことが多い。
それぞれのウィジェットの内部状態を維持し、getter/setterを公開することでアプリロジックから参照できるようにしている。

Composeのような宣言的なアプローチでは、ウィジェットは基本的にはステートレスで、getter/setterは公開しない。
事実ウィジェットはオブジェクトとしては公開されない。
Composable関数を異なる引数を渡して呼び出すことでUIを更新する。
これにより[Guide to app architecture](https://developer.android.com/jetpack/guide)で記述されているように、`ViewModel`のようなアーキテクチャパターンに状態を提供することが容易になる。
Composableは監視しているデータが更新されるたびにアプリの状態をUIに変換する役割を果たす。

Figure 2：アプリロジックはトップレベルのComposable関数にデータを提供し、他のComposable関数をデータを引き渡していく。

ユーザがUIを操作すると、`onClick`のようなイベントを通知する。
これらのイベントはアプリロジックに通知され、アプリの状態を更新することができる。
状態が更新されたら、Composable関数は再度新しいデータを使って呼び出される。
これらのUI要素の再描画は`recomposition`と呼ばれる。

Figure 3：ユーザがUI要素を操作すると、イベントが発生する。アプリロジックはイベントに反応し、Composable関数は必要があれば自動的に新しいパラメータで再実行される。

## Dynamic content

Composable関数はxmlの代わりにKotlinで書かれるので、リストUIをfor文を使って表現するなど動的な記述することができる。

if文で特定のUI操作を表示するかを切り替えることや、ループやヘルパー関数などKotlinの柔軟性をフルに活用することができるのはJetpack Composeの利点の一つ。

## Recomposition

命令的なUIモデルではsetterを呼び出すことでウィジェットの内部状態を変更する。
ComposeではComposable関数が新しいデータで再度実行される。
関数によって生成されたウィジェットは必要に応じて新しいデータで再描画される。
Composeフレームワークは変更されたコンポーネントのみを再構築する。

例えばボタンを表示するケースだと

ボタンをクリックするたびに、`clicks`が呼び出される。
Composeはラムダを呼び出し、新しいデータで`Text`関数を再度呼び出す。
データに依存しない他の関数は再コンパイルされない。

UIツリー全体を再構築するには計算コストがかかるので、計算能力とバッテリーを消費するが、Composeはこれらの仕組みによって解決している。

`Recomposition`はインプットが更新された時に再度Composable関数が呼び出されるプロセスのこと。
新しいインプットによって再度Composable関数が呼び出される時、変更された可能性のある関数やラムダのみを呼び出し、それ以外はスキップする。
不要な処理をスキップすることでComposeは効率的に再構築することができる。

関数の再コンパイルがスキップされる可能性があるのでComposable関数は実行による副作用に依存しないようにする必要がある。
副作用があると、想定外の動作が発生する可能性がある。
副作用とはアプリの他の部分から見える変化のことで以下は全て危険な副作用となる。

* 共有オブジェクトをプロパティとして記述
* ViewModel 内の Observable を更新
* SharedPreferenceを更新

Composable関数はアニメーションの描画などではフレーム毎に再実行される可能性がある。
Composable関数はスムーズなアニメーションにするために高速である必要がある。
SharedPreferenceからの読み込みなどコストがかかる操作が必要な場合は、コルーチンでの実行やComposable関数に引数として渡す。

SharedPreferencesの値を更新する例では、Composable関数ではSharedPreferencesの読み書きを行うべきではない。
代わりに、ViewModelのコルーチン内で実行する必要がある。
アプリロジックは現在の値を引数で私、更新はコールバックで通知する。

Composeで実装する場合、以下に注意する。

* Composable関数は任意の順番で実行することができる
* Composable関数は並列実行ができる
* 再コンパイルでは可能な限りComposable関数やラムダをスキップする
* 再コンパイルはキャンセルされる可能性がある
* Composable関数はアニメーションなどフレーム毎に頻繁に実行される可能性がある

再コンパイルをサポートするためにComposable関数のビルド方法を次のセクションでカバーする。

### Composable functions can execute in any order

Compsable関数内で複数のComposable関数を呼び出しているとき実行順は記述順とは限らない。
Composeでは一部の優先度の高いUI要素を先に描画するオプションが存在する。

これらはグローバル変数を変更し、他のComposable関数で利用するなどはできないということ。

### Composable functions can run in parallel

ComposeはCompsable関数を並列で実行することで再コンパイルを最適化することができる。
これによりComposeは複数のコアを活用し、画面に表示されていないCompsable関数をより低い優先度で実行することが可能。

これらの最適化はバックグラウンドスレッドで実行される可能性があることを意味している。
Composable関数を`ViewModel`上で呼び出した場合、Composeは同時に複数スレッドから呼び出される可能性がある。

アプリが正しく動作するために、Composable関数は副作用を持ってはいけない。
代わりに必ずUIスレッド上で実行される`onClick`のようなコールバックを利用する。

Composable関数が呼び出される時、呼び出し元とは異なるスレッドで呼び出される可能性がある。
これはComposableなラムダ内の変数をコードは避ける必要があることを意味している。

リストと数を表示する例では、渡された引数から数を取得すれば副作用がなく正常に動作する。
数を変数として保存してしまうとスレッドセーフではなく正常に動作しなくなってしまう。

この例では、`items` が変更されると再コンパイルされる。
アニメーションやリストの更新のたびに変更される可能性がある。
UIは誤った数を表示してしまう。
Composeではこのような書き込みはサポートされていない。

### Recomposition skips as much as possible

UIの一部が無効な場合、Composeは更新が必要な部分だけ再コンパイルする。
UIツリーの中で上下のComposable関数は呼び出されずにボタンのみが再実行される可能性があることを意味している。

Compsable関数やラムダは自身を再コンパイルする可能性がある。
複数のUI要素を描画する例では、`header` の変更時は親のComposeを実行せずに`Column`ラムダにスキップする可能性がある。
また、`Column`を実行する際に、`name`が変更されていない場合は`LazyColumnFor`がスキップされる可能性がある。

Composable関数やラムダは副作用があってはならない。
副作用がある処理を実行する必要がある場合はコールバックを経由すること。

### Recomposition is optimistic

再コンパイルはComposable関数のパラメータが変更された時にいつでも開始される。
`Recomposition is optimistic` とはパラメータが再び変更される前に再コンパイルが完了することを意味していて、再コンパイルが終わる前にパラメータが変更された場合は、再コンパイルはキャンセルされ新しいパラメータで再度実行される。

再コンパイルがキャンセルされた時、Composeは再コンパイルによるUIツリーは破棄する。
もし、副作用があるコードに依存していると、キャンセルされた時にでも適用されてしまい不正な状態が起きる可能性がある。

これらに対応するために副作用があってはならない。

### Composable functions might run quite frequently

いくつかのケースではCompsableはアニメーションの毎フレームで実行される可能性がある。
関数内でストレージ読み込みなどコストが高い処理を実行していると、アニメーションがスムーズにいかない。

例えば、デバイス設定を読み込もうとすると、1秒間に何百回も設定を読み込んでしまいパフォーマンスに影響を与える可能性がある。

Composable関数でデータが必要な場合はパラメータとして渡す必要がある。
コストが高い処理はComposable関数外の別スレッドで動作させることが可能で、`mutableStateOf`や`LiveData`を使ってデータを渡すことができる。
